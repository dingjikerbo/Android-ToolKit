status_t GraphicBufferAllocator::alloc(uint32_t width, uint32_t height,
94        PixelFormat format, uint32_t usage, buffer_handle_t* handle,
95        uint32_t* stride)
96{
97    ATRACE_CALL();
98
99    // make sure to not allocate a N x 0 or 0 x N buffer, since this is
100    // allowed from an API stand-point allocate a 1x1 buffer instead.
101    if (!width || !height)
102        width = height = 1;
103
104    // we have a h/w allocator and h/w buffer is requested
105    status_t err;
106
107    // Filter out any usage bits that should not be passed to the gralloc module
108    usage &= GRALLOC_USAGE_ALLOC_MASK;
109
110    int outStride = 0;
111    err = mAllocDev->alloc(mAllocDev, static_cast<int>(width),
112            static_cast<int>(height), format, static_cast<int>(usage), handle,
113            &outStride);
114    *stride = static_cast<uint32_t>(outStride);
115
116    ALOGW_IF(err, "alloc(%u, %u, %d, %08x, ...) failed %d (%s)",
117            width, height, format, usage, err, strerror(-err));
118
119    if (err == NO_ERROR) {
120        Mutex::Autolock _l(sLock);
121        KeyedVector<buffer_handle_t, alloc_rec_t>& list(sAllocList);
122        uint32_t bpp = bytesPerPixel(format);
123        alloc_rec_t rec;
124        rec.width = width;
125        rec.height = height;
126        rec.stridwe = *stride;
127        rec.format = format;
128        rec.usage = usage;
129        rec.size = static_cast<size_t>(height * (*stride) * bpp);
130        list.add(*handle, rec);
131    }
132
133    return err;
134}